---
title: "Stat3_BIN_Les14_v4"
author: "Emile Apol"
date: "3/31/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



###############################################################################
#
# Statistiek 3 BIN
#
# 2019-2020
#
# Emile Apol 
#
# Les 14 - Clustering 3
#
###############################################################################



###############################################################################
#
# Voorbeeld 14.1 - Poissonverdeling van vals positieve uitslagen
#
###############################################################################

Stel: MA analyse met G = 1000 genen en toetsen met significantie alpha = 0.05. 

```{r}
alpha <- 0.05
G <- 1000

n.FP.av <- G*alpha
cat("\nGemiddeld aantal FP genen: ",n.FP.av,"\n")

# Parameter van Poisson verdeling:
lambda <- n.FP.av

curve(dpois(x, lambda = lambda), from = 0, to = 2*lambda, n = 2*lambda+1, add = F, type = "l", col = "red",
      xlab = "Aantal vals positieven, FP", ylab = "Kansverdeling, p(FP)")


```

Bereken het 95% BI voor het gemiddeld aantal vals positieven bij een MA analyse.

```{r}
BI <- qpois(c(0.025, 0.975), lambda = lambda)
cat("Het 95% BI voor het aantal FP genen bij ",G," onderzochte genen is: [",BI,"]\n")
```


a) Voer dezelfde berekening uit voor G = 100 000 genen.


```{r}
alpha <- 0.05
G <- 100000

n.FP.av <- G*alpha
cat("\nGemiddeld aantal FP genen: ",n.FP.av,"\n")

# Parameter van Poisson verdeling:
lambda <- n.FP.av

curve(dpois(x, lambda = lambda), from = 0, to = 2*lambda, n = 2*lambda+1, add = F, type = "l", col = "red",
      xlab = "Aantal vals positieven, FP", ylab = "Kansverdeling, p(FP)")

BI <- qpois(c(0.025, 0.975), lambda = lambda)
cat("Het 95% BI voor het aantal FP genen bij ",G," onderzochte genen is: [",BI,"]\n")

```


b) Voer dezelfde berekening uit voor G = 20 genen.

```{r}
alpha <- 0.05
G <- 20

n.FP.av <- G*alpha
cat("\nGemiddeld aantal FP genen: ",n.FP.av,"\n")

# Parameter van Poisson verdeling:
lambda <- n.FP.av

curve(dpois(x, lambda = lambda), from = 0, to = 5*lambda, n = 5*lambda+1, add = F, type = "l", col = "red",
      xlab = "Aantal vals positieven, FP", ylab = "Kansverdeling, p(FP)")

BI <- qpois(c(0.025, 0.975), lambda = lambda)
cat("Het 95% BI voor het aantal FP genen bij ",G," onderzochte genen is: [",BI,"]\n")

```





###############################################################################
#
# Voorbeeld 14.2 - hierarchisch en k-means clustering: 4 genen, 2 samples
#
###############################################################################

We hebben een dataset van de logfold waarden M van twee samples t.o.v. een referentie, gemeten met 2-channel MA's.

```{r}
myData <- data.frame(M.1 = c(8.0, 7.0, 6.0, 2.0),
                     M.2 = c(8.0, 8.0, 6.0, 3.0))
rownames(myData) <- paste0("Gene ",LETTERS[1:4])
myData
```

a) Maak een mooie scatterplot van de log genexpressies van sample 2 als functie van de log genexpressie van sample 1 (dus M.1 langs de x-as en M.2 langs de y-as). Annoteer de datapunten met de gennaam. Hint: gebruik de functie text().

```{r}
plot(M.2 ~ M.1, data = myData, pch=19, xlim = c(0, 10), ylim = c(0, 10),
     xlab = "Log genexpressie sample 1, M.1",
     ylab = "Log genexpressie sample 2, M.2")
text(myData$M.1, myData$M.2, labels = rownames(myData), pos = 1)
```


b) Wat lijkt op basis van Euclidische afstanden een redelijke clustering?

A en B vormen zeker een subcluster, waarschijnlijk met C. D is redelijk anders dus zou een eigen subcluster kunnen vormen.


c) Cluster deze genen o.b.v. Euclidische afstand en "average" linkage. Maak een dendrogram. Hint: het de optie hang=-1 kun je het dendrogram mooier maken, door de "takken" door te laten trekken tot de basis.

```{r}
dMat  <- dist(myData, method="euclidean")
clust <- hclust(dMat, method="average")
plot(clust, xlab="Genen", ylab="Euclidische afstand", hang=-1, sub = "")



```

d) Maak m.b.v. de functie cutree 2 subclusters van dit dendrogram. Welke genen horen in welk subcluster?

```{r}
sc <- cutree(clust, k=2)

cat("Subcluster 1 bestaat uit genen: ", rownames(myData)[sc==1],"\n\n")
cat("Subcluster 2 bestaat uit genen: ", rownames(myData)[sc==2],"\n\n")

```


e) Voer k-means clustering uit met k=2 clusters; gebruik 5 random runs. Welke genen horen in welk subcluster?

```{r}
# k-means clustering:
kcl <- kmeans(myData, centers = 2, nstart = 5)


kc <- kcl$cluster

cat("Subcluster 1 bestaat uit genen: ", rownames(myData)[kc==1],"\n\n")
cat("Subcluster 2 bestaat uit genen: ", rownames(myData)[kc==2],"\n\n")
```

f) Source de R-code "Dendrograms_v8.R" (zie R-functies op BlackBoard). Maak een "dendrogram" van de k-means clustering van e. m.b.v. de speciale functie makeKMeansDendrogram().


```{r}
setwd("H:\\Hanze\\ILST\\vakken/kwartaal 07/Statistiek 3 BIN/lessen/2019-2020/Les 14 - Clustering 3/")
dir()

source("Dendrograms_v8.R")
```

```{r}
clust <- makeKMeansDendrogram(kcl)
plot(clust, hang=-1, xlab = "Genen", ylab = "", main = "K-Means dendrogram", sub = "", axes = F)
```




###############################################################################
#
# Voorbeeld 14.3 - Broodbeleg (1)
#
###############################################################################


Van bijna al onze etenswaren staat op het etiket de nutrientensamenstelling vermeld. Dit bestaat o.a. uit de hoeveelheid eiwit, suikers, zetmeel, vetten, vezels en natrium per 100 g product. In deze opgave gaan we verschillende soorten broodbeleg (jam, kaas, vlees, vlokken, hagelslag etc.) vergelijken en clusteren op basis van nutrientensamenstelling.

De dataset “Broodbeleg_1.txt” bevat voor 27 verschillende producten o.a. de waarden van de 7 eigenschappen:

  eiwit        = g eiwit per 100 g product
  kool.suiker  = g suiker per 100 g product
  kool.anders  = g overige koolhydraten (zetmeel) per 100 g product
  vet.vz       = g verzadigd vet per 100 g product
  vet.ov       = g onverzadigd vet per 100 g product
  vez          = g voedingsvezels per 100 g product
  Na           = g natrium per 100 g product
  
Daarnaast is er o.a. nog een kolom Omschrijving die aangeeft welk product het is (met fabrikant).

a) Lees in R deze tab-separated dataset met header in als dataframe myData.

```{r}
setwd("H:/Hanze/ILST/vakken/kwartaal 07/Statistiek 3 BIN/lessen/2019-2020/Les 14 - Clustering 3/")
dir()

myData <- read.table("Broodbeleg_1.txt", header=T)

View(myData)
head(myData)
```


b) Maak uit dataframe myData een nieuw dataframe M door alleen de 7 bovengenoemde nutrienten (eiwit, kool.suiker, ..., Na) te selecteren, en de "Omschrijving" als rownames te gebruiken. NB. Het is belangrijk om de juiste rownames in het dataframe te hebben wat je wilt gaan clusteren, zodan in het dendrogram elk item duidelijk herkanbaar is!


```{r}
properties <- c("eiwit", "kool.suiker", "kool.anders", "vet.vz", "vet.ov", "vez", "Na" )
prod.names <- myData$Omschrijving

M <- myData[, properties]
rownames(M) <- prod.names
View(M)
```

c) Voer een hiërarchische clustering uit op de 27 soorten broodbeleg op basis van de 7 nutrienten. Gebruik “euclidean” afstanden en “average” linkage. Maak via plot een dendrogram. Je kunt de grootte van de labels aanpassen via cex. Pas de uitlijning van de labels aan via hang=-1.

```{r}
dMat <- dist(M, method="euclidean")
clust <- hclust(dMat, method="average")

plot(clust, hang=-1,
     xlab="Producten", ylab="Afstand (Euclidisch)", sub="",
     cex=0.7)
```

d) Gebruik de functie cutree (zie ppt van Les 13) om twee subclusters te maken. Wat zijn de producten in beide subclusters? 

```{r}
sc.2 <- cutree(clust, k=2)

cat("Producten in subcluster 1 zijn: ", as.character(prod.names[sc.2==1]), "\n\n")
cat("Producten in subcluster 2 zijn: ", as.character(prod.names[sc.2==2]), "\n\n")

# OF

cat("Producten in subcluster 1 zijn: ", rownames(M)[sc.2==1], "\n\n")
cat("Producten in subcluster 2 zijn: ", rownames(M)[sc.2==1], "\n\n")
```


e) Voer k-means clustering uit met k=2 clusters; gebruik 5 random runs. Welke producten horen in welk subcluster?

```{r}
# k-means clustering:
kcl <- kmeans(M, centers = 2, nstart = 5)

kc <- kcl$cluster

cat("Producten in subcluster 1 zijn: ", as.character(prod.names[kc==1]), "\n\n")
cat("Producten in subcluster 2 zijn: ", as.character(prod.names[kc==2]), "\n\n")

# OF

cat("Producten in subcluster 1 zijn: ", rownames(M)[kc==1], "\n\n")
cat("Producten in subcluster 2 zijn: ", rownames(M)[kc==2], "\n\n")

```

f) Source de R-code "Dendrograms_v8.R" (zie R-functies op BlackBoard). Maak een "dendrogram" van de k-means clustering van e. m.b.v. de speciale functie makeKMeansDendrogram(). Hint: met de optie cex kun je de grootte van de x-labels aanpassen.

```{r}
setwd("H:\\Hanze\\ILST\\vakken/kwartaal 07/Statistiek 3 BIN/lessen/2019-2020/Les 14 - Clustering 3/")
dir()

source("Dendrograms_v8.R")

clust <- makeKMeansDendrogram(kcl)
plot(clust, hang=-1, xlab = "Producten", ylab = "", main = "K-Means dendrogram", sub = "", axes = F, cex = 0.8)
```


g) Vergelijk de hierarchische en k-means clusteringen.

Beide clusteringen (in termen van 2 "subclusters") zijn gelijk!




###############################################################################
#
# Voorbeeld 14.4 - k-mean clusteren: 9 genen, 2 samples
#
###############################################################################


```{r}
myData <- data.frame(M.1 = c(-3.0, -2.0, -2.0, -3.0, 0.0, 2.0, 3.0, 3.0, 2.0),
                     M.2 = c(-2.0, -2.0, -3.0, -3.0, 0.0, 2.0, 2.0, 3.0, 3.0))
rownames(myData) <- paste0("Gene ",LETTERS[1:9])
myData
```

a) Maak een mooie scatterplot van de log genexpressies van sample 2 als functie van de log genexpressie van sample 1 (dus M.1 langs de x-as en M.2 langs de y-as). Annoteer de datapunten met de gennaam. Hint: gebruik de functie text().

```{r}
plot(M.2 ~ M.1, data = myData, pch=19, xlim = c(-4, 4), ylim = c(-4, 4),
     xlab = "Log genexpressie sample 1, M.1",
     ylab = "Log genexpressie sample 2, M.2")
text(myData$M.1, myData$M.2, labels = rownames(myData), pos = 1)
```


b) Wat lijkt op basis vann deze plot een "logische" indeling in "subclusters"?

A+B+C+D, E, F+G+H+I

c) Voer een hiërarchische clustering uit op de 9 genen op basis van de 2 samples. Gebruik “euclidean” afstanden en “average” linkage. Maak via plot een dendrogram. Je kunt de grootte van de labels aanpassen via cex. Pas de uitlijning van de labels aan via hang=-1. 



```{r}
dMat <- dist(myData, method="euclidean")
clust <- hclust(dMat, method="average")

plot(clust, hang=-1,
     xlab="Producten", ylab="Afstand (Euclidisch)", sub="",
     cex=0.8)
```


d) Bepaal m.b.v. de functie cutree() welke 3 "subclusters" er zijn, en welke genen in welk subcluster zitten.

```{r}
sc <- cutree(clust, k=3)

cat("Subcluster 1 bestaat uit genen: ", rownames(myData)[sc==1],"\n\n")
cat("Subcluster 2 bestaat uit genen: ", rownames(myData)[sc==2],"\n\n")
cat("Subcluster 3 bestaat uit genen: ", rownames(myData)[sc==3],"\n\n")
```

e) Voer k-means clustering uit met k=2 clusters; gebruik 1 random runs. Welke genen horen in welk subcluster?

```{r}
# k-means clustering:
kcl <- kmeans(myData, centers = 2, nstart = 1)


kc <- kcl$cluster

cat("Subcluster 1 bestaat uit genen: ", rownames(myData)[kc==1],"\n\n")
cat("Subcluster 2 bestaat uit genen: ", rownames(myData)[kc==2],"\n\n")

```

f) Voer een paar keer k-means clustering uit met k=2 clusters. Krijg je steeds dezelfde clustering?


```{r}
# k-means clustering:
kcl <- kmeans(myData, centers = 2, nstart = 1)

kc <- kcl$cluster

cat("Subcluster 1 bestaat uit genen: ", rownames(myData)[kc==1],"\n\n")
cat("Subcluster 2 bestaat uit genen: ", rownames(myData)[kc==2],"\n\n")

```
Nee, gen E hoort soms bij de ene, dan weer bij de andere cluster...

g) Bepaal de totale SS.within als functie van het aantal clusters k (zie Powerpoint Les 14). Wat is voor deze data het optimale aantal clusters?

```{r}
( k.max <- nrow(myData) )
( k <- 1:(k.max - 1) )
( wss <- (k.max - 1) * sum(apply(myData, 2, var)) )
for (i in 2:(k.max - 1)){
  wss[i] <- kmeans(myData, centers = i)$tot.withinss
}

plot(k, wss, type = "b", pch=19,
     xlab = "Aantal clusters, k",
     ylab = "Totale SS.within = SS.err")
```


Er is een "knik" in de figuur bij k = 2 (of k = 3), dus 2 (of 3) clusters lijkt statistisch gezien het meest logisch...

h) Maak een mooie scatterplot van de log genexpressies van sample 2 als functie van de log genexpressie van sample 1 (dus M.1 langs de x-as en M.2 langs de y-as). Geef de punten een kleur volgens de hierarchische subclusters met k = 3. Hint: in R hebben de kleuren ook een nummer vanaf 1...

```{r}
plot(M.2 ~ M.1, data = myData, pch=19, xlim = c(-4, 4), ylim = c(-4, 4),
     xlab = "Log genexpressie sample 1, M.1",
     ylab = "Log genexpressie sample 2, M.2",
     col = sc)
```



###############################################################################
#
# Voorbeeld 14.5 - Gepaarde t-toets en block ANOVA (1)
#
###############################################################################

We hebben de volgende data van de expressie van een bepaald gen o.b.v. 3 dual-channel microarray metingen: 
In "wide" format:

         sample  logR    logG
           1       1       4
           2       3       5 
           3       5       7

waarbij R en G de genexpressie zijn voor zieke en gezonde personen (d.w.z. 2 levels van factor A = gezondheid).

In "MA" format:

         logR.1  logR.2  logR.3  logG.1  logG.2  logG.3
           1       3       5       4       5       7


```{r}
( y <- c(1, 3, 5, 4, 5, 7) )
( A <- factor(rep(c("R", "G"), each = 3)) )
( sample <- factor(paste0("Sample.",rep(1:3, 2))) )
```

a) Maak een boxplot van de genexpressie als functie van gezondheid (factor A).

```{r}
boxplot(y ~ A, xlab = "Gezondheid", ylab = "Log genexpressie")
```

b) Welke toets is het geschiktste om te onderzoeken of gezondheid een significant effect heeft op de expressie van dit gen?

Een gepaarde t-toets, want de metingen zijn herhaalde metingen: zowel R als G zijn door hetzelfde MA gemeten.

c) Komt dit gen differentieel tot expressie? Leg uit. Toets met alpha = 0.05.

```{r}
t.test(y ~ A, paired = T)
```
 De p-waarde is p = 0.0198 < 0.05, dus het gen komt differentieel tot expressie.
 
 d) Voer ook een block ANOVA uit. Verschilt het resultaat met de analyse van c.? Leg kort uit.
 
```{r}
summary(aov(y ~ A + sample))
```
 
p.A = 0.0198 < < 0.05, dus het gen komt differentieel tot expressie.

Het resultaat (d.w.z. de p-waarde van de toets) is identiek aan die van de gepaarde t-toets.
Een block ANOVA voor 2 levels van factor A is wiskundig gelijk aan een gepaarde t-toets, dus dat klopt!

e) Wat is de effectsterkte van de factor gezondheid? Heeft gezondheid een zwak, matig of sterk effect op de genexpressie?

```{r}
# Voor de gepaarde t-toets:
fit.t <- t.test(y ~ A, paired = T)
means <- tapply(y, A, mean)
vars <- tapply(y, A, var)
d.av <- (means[1]-means[2])/sqrt( sum(vars)/2 )

cat("Effectsterkte: d.av = ",d.av,"\n")


```

d.av > 0.8, dus gezondheid heeft een heel sterk effect op de genexpressie.


f) Maak van het "long" format een dataframe, en zet dit om naar een "wide" format dataframe met sample als rownames (zie ook Les 11).

```{r}
LongData <- data.frame(y, A, sample)
View(LongData)


# Eerst juist sorteren zodat factor sample weer rownames kan worden:
LongData <- LongData[order(LongData$A, LongData$sample), ]
# Unstack naar "wide":
WideData <- unstack(LongData, y ~ A)
rownames(WideData) <- levels(LongData$sample)
WideData
View(WideData)

```
g) Omdat de data gepaard gemeten zijn, is i.p.v. een gewone boxplot een "gepaarde" boxplot mooier: ggpaired uit package ggpubr. Deze functie heeft als input de data als "wide" format, zie ook Les 09.

```{r}
library(ggpubr)

ggpaired(data = WideData, cond1 = "G", cond2 = "R", xlab = "Gezondheid",
         ylab = "Log genexpressie")
```


###############################################################################
#
# Voorbeeld 14.6 - Gepaarde t-toets en block ANOVA (2)
#
###############################################################################

We hebben de volgende data van de expressie van een bepaald gen o.b.v. 3 4-channel microarray metingen: 
In "wide" format:

         sample  logR    logG    logB    logY
           1       1       3       0       2
           2       3       5       2       3
           3       5       6       4       6

waarbij R, G, B en Y de genexpressie zijn voor zieke en gezonde personen (d.w.z. 4 levels van factor A = gezondheid).

In "MA" format:

         logR.1  logR.2  logR.3  logG.1  logG.2  logG.3  logB.1  logB.2  logB.3  logY.1  logY.2  logY.3
           1       3       5       3       5       6       0       2       4       2       3       6

```{r}
( y <- c(1, 3, 5, 3, 5, 6, 0, 2, 4, 2, 3, 6) )
( A <- factor(rep(c("R", "G", "B", "Y"), each = 3)) )
( sample <- factor(paste0("Sample.", rep(1:3, 4))) )
```

a) Maak een boxplot van de genexpressie als functie van gezondheid (factor A).

```{r}
boxplot(y ~ A, xlab = "Gezondheid", ylab = "Log genexpressie")
```

b) Welke toets is het geschiktste om te onderzoeken of gezondheid een significant effect heeft op de expressie van dit gen?

Een block ANOVA, want de metingen zijn herhaalde metingen: zowel R, G, B als Y zijn door hetzelfde MA gemeten.


c) Komt dit gen differentieel tot expressie? Leg uit. Toets met alpha = 0.05.

 
```{r}
summary(aov(y ~ A + sample))
```
 
p.A = 0.00172 < 0.05, dus het gen komt differentieel tot expressie.


d) Wat is de effectsterkte van de factor gezondheid? Heeft gezondheid een zwak, matig of sterk effect op de genexpressie?

```{r}
# Voor de gepaarde t-toets:
fit <- summary(aov(y ~ A + sample))
eta2 <- fit[[1]]$Sum[1]/sum(fit[[1]]$Sum)

cat("Effectsterkte: eta2 = ",eta2,"\n")


```

eta2  > 0.14, dus gezondheid heeft een heel sterk effect op de genexpressie.


e) Maak van het "long" format een dataframe, en zet dit om naar een "wide" format dataframe met sample als rownames (zie ook Les 11).

```{r}
LongData <- data.frame(y, A, sample)
View(LongData)


# Eerst juist sorteren zodat factor sample weer rownames kan worden:
LongData <- LongData[order(LongData$A, LongData$sample), ]
# Unstack naar "wide":
WideData <- unstack(LongData, y ~ A)
rownames(WideData) <- levels(LongData$sample)
WideData
View(WideData)

```

f) Omdat de data gepaard gemeten zijn, is i.p.v. een gewone boxplot wellicht informatiever om de data in het "wide" format m.b.v. de functie matplot() en matlines() te plotten, zie ook Les 12. Plot op deze manier de log genexpressie als functie van factor A (= gezondheid), met voor elk sample een andere kleur.

```{r}
matplot(t(WideData), pch = 19, type = "b", lty = 1, 
        xlab = "Gezondheid", ylab = "Log(gene expression)", axes = F)
axis(side = 2, at = 0:10)
axis(side = 1, at = 1:ncol(WideData), labels = colnames(WideData)) 
legend(x = "top", legend = rownames(WideData), col=as.factor(rownames(WideData)),
       pch = 19, lty = 1)

```

g) Wat was de conclusie geweest als je de data m.b.v. een 1-way ANOVA had geanalyseerd?

```{r}
summary(aov(y ~ A))
```

p = 0.429 >> 0.05, dus geen significante invloed van gezondheid op de genexpressie.

h) Leg uit waarom dit resultaat anders is dan bij c.

Dat komt omdat de expressieniveau's erg verschilt tussen de samples, dat levert extra "ruis" op die d.m.v. de blaock ANOVA deels wordt weggefilterd.



###############################################################################
#
# Voorbeeld 14.7 - T-toetsen en ANOVA's (1)
#
###############################################################################

Gen expressie data gemeten met een Dual Channel Microarray: 7 replica's (= samples), M = log(R)-log(G) = log(R/G) waarden voor 25 genen (= regels). Op de data is al een background correctie en een normalisatie toegepast.

Datafile: "Dual_Channel_variation1.txt"


a) Lees de data in. Schrijf een eigen 1-sample t functie om de DEG's te vinden, pas je functie toe op de data en pas vervolgens 
Bonferroni correctie toe. Welke genen zijn DEG's?

Inlezen data:

```{r}
setwd("H:\\Hanze\\ILST\\vakken/kwartaal 07/Statistiek 3 BIN/lessen/2019-2020/Les 14 - Clustering 3/")
myData <- read.table("Dual_Channel_variation1.txt", header = T, sep = "\t")
```
Eigen t-toets:

```{r}
my1SampleTTest <- function(x){
  return(t.test(x, mu = 0)$p.value)
}
```

Analyseren per gen:

```{r}
pVals <- apply(myData, 1, my1SampleTTest)
```

Bonferroni correctie:
 
```{r}
pVals.corr <- p.adjust(pVals, method = "bonferroni")

cat("Aantal DEG's: ", sum(pVals.corr < 0.05),"\n\n")
DEGs <- rownames(myData)[pVals.corr < 0.05]
cat("DEG's: ",DEGs,"\n")
```

b) Maak een nieuw dataframe met daarin alleen alle M-waarden van de DEG's.

```{r}
MA.DEG <- myData[DEGs, ]
View(MA.DEG)
```

c) Maak met de functie matplot en matlines een grafiek van M-waarden als functie van sample. Per gen een andere kleur.

```{r}
par(bg = "lightgrey")
matplot(t(MA.DEG), pch = 19, type = "b", lty = 1, 
        xlab = "Gezondheid", ylab = "Log genexpressie", axes = F, 
        col = factor(rownames(MA.DEG), levels = rownames(MA.DEG)))
axis(side = 2, at = -5:10)
axis(side = 1, at = 1:ncol(MA.DEG), labels = colnames(MA.DEG)) 
legend(x = "right", legend = rownames(MA.DEG), col=factor(rownames(MA.DEG), levels = rownames(MA.DEG)),
       pch = 19, lty = 1)

# LET OP: Zonder zelf de level volgorde van de rownames aan te passen kloppen de kleuren niet, want "gene13" komt alfabetisch voor "gene2"... Col wil de nummers van de kleuren, dus moeten de gennamen goed op volgorde staan!

```


d) Voer hierarchische clustering uit op deze DEG's met Euclidische afstand en "average" linkage. Maak een dendrogram.

```{r}
dMat <- dist(MA.DEG, method="euclidean")
clust <- hclust(dMat, method="average")
plot(clust, hang=-1, xlab="Genen", ylab="Euclidische afstand",
     main="Dendrogram DEG's", sub="")
```

e) Welke k = 3 subclusters zijn er? Welke genen horen bij welke subcluster? Gezien het dendrogram, lijkt dit een "logische" gen-indeling?

```{r}
sc <- cutree(clust, k=3)

cat("Subcluster 1 bestaat uit genen: ", rownames(MA.DEG)[sc==1],"\n\n")
cat("Subcluster 2 bestaat uit genen: ", rownames(MA.DEG)[sc==2],"\n\n")
cat("Subcluster 3 bestaat uit genen: ", rownames(MA.DEG)[sc==3],"\n\n")
```
Logischer zou zijn dat gen 1+3, gen 13+5+21 en gen 2+8 subclusters vormen, maar dat klopt niet qua Euclidische afstanden...


f) Voer k-means clustering uit met k = 3 clusters, gebruik nstart = 5 pogingen. Welke genen horen bij welke (sub)cluster? Maak ook een dendrogram.

```{r}
kcl <- kmeans(MA.DEG, centers = 3, nstart = 5)

kc <- kcl$cluster

cat("Subcluster 1 bestaat uit genen: ", rownames(MA.DEG)[kc==1],"\n\n")
cat("Subcluster 2 bestaat uit genen: ", rownames(MA.DEG)[kc==2],"\n\n")
cat("Subcluster 3 bestaat uit genen: ", rownames(MA.DEG)[kc==3],"\n\n")
```
```{r}
source("Dendrograms_v8.R")

clust <- makeKMeansDendrogram(kcl)
plot(clust, hang=-1, xlab = "Genen", ylab = "", main = "K-Means dendrogram", sub = "", axes = F, cex = 1.0)
```

Dit lijkt meer te kloppen met de "intuitieve" subclustering van het hierarchische dendrogram!


g) Voer hierarchische clustering uit met Absolute Pearson afstanden en "average" linkage. Maak een dendrogram.

```{r}
dMat  <- as.dist(1 - abs(cor(t(MA.DEG))))
clust <- hclust(dMat, method="average")
plot(clust, xlab="Genen", ylab="Absolute Pearson afstand", hang=-1, sub = "")
```


h) Maak een heapmap van de DEG's, en cluster alleen de genen met Euclidische afstanden en "average" linkage.

```{r}
# Definieer eigen kleurpalet:

MA.color <- function(n=11){
  colorRampPalette(c("blue", "white", "orange"), space = "rgb")(n)
}

# Definieer zelf eigen distance en linkage functies:

myDist <- function(x){
  return(dist(x, method = "euclidean"))
}

myHClust <- function(x){
  return(hclust(x, method = "average"))
}

# netste manier: via heatmap.2 in gplots

library("gplots")
heatmap.2(as.matrix(myData), distfun=myDist, hclustfun = myHClust, 
          symbreaks = T, trace = "none", scale = "none", col = MA.color(), Colv = NA)
```



i) Maak een heapmap van de DEG's, en cluster alleen de genen met Absolute Pearson afstanden en "average" linkage.

```{r}
# Definieer eigen kleurpalet:

MA.color <- function(n=11){
  colorRampPalette(c("blue", "white", "orange"), space = "rgb")(n)
}

# Definieer zelf eigen distance en linkage functies:

myDist <- function(x){
  return(as.dist(1 - abs(cor(t(x)))))
}

myHClust <- function(x){
  return(hclust(x, method = "average"))
}

# netste manier: via heatmap.2 in gplots

library("gplots")
heatmap.2(as.matrix(myData), distfun=myDist, hclustfun = myHClust, 
          symbreaks = T, trace = "none", scale = "none", col = MA.color(), Colv = NA)
```






###############################################################################
#
# Voorbeeld 14.8 - T-toetsen en ANOVA's (2)
#
###############################################################################

Gen expressie data gemeten met een Dual Channel Microarray: 7 replica's (= samples), log(R) en log(G) waarden voor 25 genen (= regels). Op de data is al een background correctie en een normalisatie toegepast.

Datafile: "Dual_Channel_variation2.txt"


a) Lees de data in. Schrijf een eigen gepaarde t functie om de DEG's te vinden, pas je functie toe op de data en pas vervolgens 
Bonferroni correctie toe. Welke genen zijn DEG's?

Inlezen data:

```{r}
setwd("H:\\Hanze\\ILST\\vakken/kwartaal 07/Statistiek 3 BIN/lessen/2019-2020/Les 14 - Clustering 3/")
myData <- read.table("Dual_Channel_variation2.txt", header = T, sep = "\t")
```
Eigen gepaarde t-toets:

```{r}
myPairedTTest <- function(x, g){
  return(t.test(x ~ g, paired = T)$p.value)
}

( g <- factor(rep(c("R", "G"), each = 7)) )
```

Analyseren per gen:

```{r}
pVals <- apply(myData, 1, myPairedTTest, g)
```

Bonferroni correctie:
 
```{r}
pVals.corr <- p.adjust(pVals, method = "bonferroni")

cat("Aantal DEG's: ", sum(pVals.corr < 0.05),"\n\n")
DEGs <- rownames(myData)[pVals.corr < 0.05]
cat("DEG's: ",DEGs,"\n")
```

b) Lees de data in. Schrijf een eigen block ANOVA functie om de DEG's te vinden, pas je functie toe op de data en pas vervolgens Bonferroni correctie toe. Welke genen zijn DEG's?

Inlezen data:

```{r}
setwd("H:\\Hanze\\ILST\\vakken/kwartaal 07/Statistiek 3 BIN/lessen/2019-2020/Les 14 - Clustering 3/")
myData <- read.table("Dual_Channel_variation2.txt", header = T, sep = "\t")
```
Eigen block ANOVA:

```{r}
myBlockAnovaTest <- function(x,g,sample){
  return(summary(aov(x ~ g + sample))[[1]]$Pr[1])
}

( g <- factor(rep(c("R", "G"), each = 7)) )
( sample <- factor(rep(1:7, 2)) )
```

Analyseren per gen:

```{r}
pVals <- apply(myData, 1, myBlockAnovaTest, g, sample)
```

Bonferroni correctie:
 
```{r}
pVals.corr <- p.adjust(pVals, method = "bonferroni")

cat("Aantal DEG's: ", sum(pVals.corr < 0.05),"\n\n")
DEGs <- rownames(myData)[pVals.corr < 0.05]
cat("DEG's: ",DEGs,"\n")
```


c) Maak een nieuw dataframe met daarin alleen alle M-waarden van de DEG's.

```{r}
MA.DEG <- myData[DEGs, ]
View(MA.DEG)
```

d) Maak met de functie matplot en matlines een grafiek van M-waarden als functie van sample. Per gen een andere kleur.

```{r}
par(bg = "lightgrey")
matplot(t(MA.DEG), pch = 19, type = "b", lty = 1, 
        xlab = "Gezondheid", ylab = "Log genexpressie", axes = F, 
        col = factor(rownames(MA.DEG), levels = rownames(MA.DEG)))
axis(side = 2, at = -5:10)
axis(side = 1, at = 1:ncol(MA.DEG), labels = colnames(MA.DEG)) 
legend(x = "right", legend = rownames(MA.DEG), col=factor(rownames(MA.DEG), levels = rownames(MA.DEG)),
       pch = 19, lty = 1)

# LET OP: Zonder zelf de level volgorde van de rownames aan te passen kloppen de kleuren niet, want "gene13" komt alfabetisch voor "gene2"... Col wil de nummers van de kleuren, dus moeten de gennamen goed op volgorde staan!

```


e) Voer hierarchische clustering uit op deze DEG's met Euclidische afstand en "average" linkage. Maak een dendrogram.

```{r}
dMat <- dist(MA.DEG, method="euclidean")
clust <- hclust(dMat, method="average")
plot(clust, hang=-1, xlab="Genen", ylab="Euclidische afstand",
     main="Dendrogram DEG's", sub="")
```

f) Welke k = 3 subclusters zijn er? Welke genen horen bij welke subcluster? Gezien het dendrogram, lijkt dit een "logische" gen-indeling?

```{r}
sc <- cutree(clust, k=3)

cat("Subcluster 1 bestaat uit genen: ", rownames(MA.DEG)[sc==1],"\n\n")
cat("Subcluster 2 bestaat uit genen: ", rownames(MA.DEG)[sc==2],"\n\n")
cat("Subcluster 3 bestaat uit genen: ", rownames(MA.DEG)[sc==3],"\n\n")
```
Klopt wel met dendrogram...


g) Voer k-means clustering uit met k = 3 clusters, gebruik nstart = 5 pogingen. Welke genen horen bij welke (sub)cluster? Maak ook een dendrogram.

```{r}
kcl <- kmeans(MA.DEG, centers = 3, nstart = 5)

kc <- kcl$cluster

cat("Subcluster 1 bestaat uit genen: ", rownames(MA.DEG)[kc==1],"\n\n")
cat("Subcluster 2 bestaat uit genen: ", rownames(MA.DEG)[kc==2],"\n\n")
cat("Subcluster 3 bestaat uit genen: ", rownames(MA.DEG)[kc==3],"\n\n")
```
```{r}
source("Dendrograms_v8.R")

clust <- makeKMeansDendrogram(kcl)
plot(clust, hang=-1, xlab = "Genen", ylab = "", main = "K-Means dendrogram", sub = "", axes = F, cex = 1.0)
```

Dit klopt met de subclustering van het hierarchische dendrogram!




